diff --git a/Makefile b/Makefile
index 4082546..9a51cba 100644
--- a/Makefile
+++ b/Makefile
@@ -1,13 +1,30 @@
-CFLAGS += -fpic -shared -std=c11 -Wall -Wextra -Wl,--version-script=exports.txt
+CC = gcc
+STRIP = strip
 
-libandroid-shmem.so: shmem.c shm.h
-	$(CC) $(CFLAGS) $(LDFLAGS) shmem.c -llog -o $@
+LIBANDROID_SHMEM_SO = libandroid-shmem.so
+TYPE = debian-noroot
 
-install: libandroid-shmem.so shm.h
-	install -D libandroid-shmem.so $(PREFIX)/lib/libandroid-shmem.so
+CFLAGS += -fPIC -shared -std=gnu99 -Wall -Wextra -Wl,--version-script=exports.txt
+LDFLAGS +=
+
+ifeq ($(TYPE), debian-noroot)
+LIBANDROID_SHMEM_SO = libandroid-shmem-termux.so
+CFLAGS += -DDEBIAN_NOROOT
+LDFLAGS += -lc -lpthread
+else
+LIBANDROID_SHMEM_SO = libandroid-shmem.so
+LDFLAGS += -llog
+endif
+
+$(LIBANDROID_SHMEM_SO): shmem.c shm.h
+	$(CC) $(CFLAGS) $(LDFLAGS) shmem.c -o $@
+	$(STRIP) $@
+
+install: $(LIBANDROID_SHMEM_SO) shm.h
+	install -D $(LIBANDROID_SHMEM_SO) $(PREFIX)/lib/$(LIBANDROID_SHMEM_SO)
 	install -D shm.h $(PREFIX)/include/sys/shm.h
 
 clean:
-	rm -f libandroid-shmem.so
+	rm -f libandroid-shmem.so libandroid-shmem-termux.so
 
 .PHONY: install
diff --git a/linux/ashmem.h b/linux/ashmem.h
new file mode 100644
index 0000000..9f537ac
--- /dev/null
+++ b/linux/ashmem.h
@@ -0,0 +1,50 @@
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+
+#ifdef DEBIAN_NOROOT
+#ifndef _LINUX_ASHMEM_H
+#define _LINUX_ASHMEM_H
+
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+#include <stdint.h>
+
+#define ASHMEM_NAME_LEN 256
+
+#define ASHMEM_NAME_DEF "dev/ashmem"
+
+#define ASHMEM_NOT_PURGED 0
+#define ASHMEM_WAS_PURGED 1
+
+#define ASHMEM_IS_UNPINNED 0
+#define ASHMEM_IS_PINNED 1
+
+struct ashmem_pin {
+ uint32_t offset;
+ uint32_t len;
+};
+
+#define __ASHMEMIOC 0x77
+
+#define ASHMEM_SET_NAME _IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])
+#define ASHMEM_GET_NAME _IOR(__ASHMEMIOC, 2, char[ASHMEM_NAME_LEN])
+#define ASHMEM_SET_SIZE _IOW(__ASHMEMIOC, 3, size_t)
+#define ASHMEM_GET_SIZE _IO(__ASHMEMIOC, 4)
+#define ASHMEM_SET_PROT_MASK _IOW(__ASHMEMIOC, 5, unsigned long)
+#define ASHMEM_GET_PROT_MASK _IO(__ASHMEMIOC, 6)
+#define ASHMEM_PIN _IOW(__ASHMEMIOC, 7, struct ashmem_pin)
+#define ASHMEM_UNPIN _IOW(__ASHMEMIOC, 8, struct ashmem_pin)
+#define ASHMEM_GET_PIN_STATUS _IO(__ASHMEMIOC, 9)
+#define ASHMEM_PURGE_ALL_CACHES _IO(__ASHMEMIOC, 10)
+
+#endif
+#endif /* DEBIAN_NOROOT */
diff --git a/shm.h b/shm.h
index f780a28..56600d1 100644
--- a/shm.h
+++ b/shm.h
@@ -11,6 +11,12 @@ __BEGIN_DECLS
 # define shmid_ds shmid64_ds
 #endif
 
+#ifdef DEBIAN_NOROOT
+typedef __key_t key_t;
+#define shmid_ds shmid64_ds
+#define ipc_perm ipc64_perm
+#endif
+
 /* Shared memory control operations. */
 extern int shmctl(int shmid, int cmd, struct shmid_ds* buf);
 
diff --git a/shmem.c b/shmem.c
index d474535..923ebb5 100644
--- a/shmem.c
+++ b/shmem.c
@@ -1,4 +1,8 @@
+#ifdef DEBIAN_NOROOT
+#define _GNU_SOURCE
+#else
 #include <android/log.h>
+#endif
 #include <errno.h>
 #include <pthread.h>
 #include <stdbool.h>
@@ -10,13 +14,26 @@
 #include <sys/un.h>
 #include <unistd.h>
 #include <paths.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdarg.h>
 
 #define __u32 uint32_t
+#ifdef DEBIAN_NOROOT
+#include "linux/ashmem.h"
+#else
 #include <linux/ashmem.h>
+#endif
 
 #include "shm.h"
 
+#ifdef DEBIAN_NOROOT
+#define DBG(fmt, ...) debug_message("[shmem] " fmt "\n", __VA_ARGS__)
+#else
 #define DBG(...) __android_log_print(ANDROID_LOG_INFO, "shmem", __VA_ARGS__)
+#endif
 #define ASHV_KEY_SYMLINK_PATH _PATH_TMP "ashv_key_%d"
 #define ANDROID_SHMEM_SOCKNAME "/dev/shm/%08x"
 #define ROUND_UP(N, S) ((((N) + (S) - 1) / (S)) * (S))
@@ -45,6 +62,42 @@ static int ashv_local_socket_id = 0;
 static int ashv_pid_setup = 0;
 static pthread_t ashv_listening_thread_id = 0;
 
+#ifdef DEBIAN_NOROOT
+static void debug_message(const char *format, ...)
+{
+	static int verbose = -1;
+	va_list ap;
+
+	if (verbose < 0) {
+		const char *quiet_env = (const char *)getenv("LIBANDROID_SHMEM_QUIET");
+		if ((quiet_env == NULL) || strncmp(quiet_env, "1", 1)) {
+			verbose = 1;
+		} else {
+			verbose = 0;
+		}
+	} else if (verbose) {
+		va_start(ap, format);
+		(void)vfprintf(stderr, format, ap);
+		va_end(ap);
+	}
+}
+
+static int shmem_disabled(void)
+{
+	static int disabled = -1;
+
+	if (disabled < 0) {
+		const char *disable_env = (const char *)getenv("LIBANDROID_SHMEM_DISABLE");
+		if ((disable_env == NULL) || strncmp(disable_env, "1", 1)) {
+			disabled = 0;
+		} else {
+			disabled = 1;
+		}
+	}
+	return disabled;
+}
+#endif
+
 static int ancil_send_fd(int sock, int fd)
 {
 	char nothing = '!';
@@ -127,11 +180,15 @@ static int ashmem_create_region(char const* name, size_t size)
 	if (fd < 0) return fd;
 
 	char name_buffer[ASHMEM_NAME_LEN] = {0};
-	strncpy(name_buffer, name, sizeof(name_buffer));
-	name_buffer[sizeof(name_buffer)-1] = 0;
-
-	int ret = ioctl(fd, ASHMEM_SET_NAME, name_buffer);
-	if (ret < 0) goto error;
+	DBG("%s: name `%s` size %d", __PRETTY_FUNCTION__, name, size);
+	int ret;
+	if(name) {
+		strncpy(name_buffer, name, sizeof(name_buffer));
+		name_buffer[sizeof(name_buffer)-1] = 0;
+
+		ret = ioctl(fd, ASHMEM_SET_NAME, name_buffer);
+		if (ret < 0) goto error;
+	}
 
 	ret = ioctl(fd, ASHMEM_SET_SIZE, size);
 	if (ret < 0) goto error;
@@ -176,9 +233,13 @@ static int ashv_socket_id_from_shmid(int shmid)
 
 static int ashv_find_local_index(int shmid)
 {
-	for (size_t i = 0; i < shmem_amount; i++)
-		if (shmem[i].id == shmid)
+	for (size_t i = 0; i < shmem_amount; i++) {
+		if (shmem[i].id == shmid) {
+			//DBG ("%s: index of shmid %08x is %d", __PRETTY_FUNCTION__, shmid, i);
 			return i;
+		}
+	}
+	DBG ("%s: cannot find shmid %x", __PRETTY_FUNCTION__, shmid);	
 	return -1;
 }
 
@@ -189,7 +250,7 @@ static void* ashv_thread_function(void* arg)
 	struct sockaddr_un addr;
 	socklen_t len = sizeof(addr);
 	int sendsock;
-	//DBG("%s: thread started", __PRETTY_FUNCTION__);
+	DBG("%s: thread started", __PRETTY_FUNCTION__);
 	while ((sendsock = accept(sock, (struct sockaddr *)&addr, &len)) != -1) {
 		int shmid;
 		if (recv(sendsock, &shmid, sizeof(shmid), 0) != sizeof(shmid)) {
@@ -197,15 +258,20 @@ static void* ashv_thread_function(void* arg)
 			close(sendsock);
 			continue;
 		}
+		if (shmid < 0x10000) {
+			shmid = ashv_shmid_from_counter(shmid);
+		}
+		DBG("%s: recv shmid %08x", __PRETTY_FUNCTION__, shmid);
 		pthread_mutex_lock(&mutex);
 		int idx = ashv_find_local_index(shmid);
 		if (idx != -1) {
-			if (write(sendsock, &shmem[idx].key, sizeof(key_t)) != sizeof(key_t)) {
-				DBG("%s: ERROR: write failed: %s", __PRETTY_FUNCTION__, strerror(errno));
-			}
 			if (ancil_send_fd(sendsock, shmem[idx].descriptor) != 0) {
 				DBG("%s: ERROR: ancil_send_fd() failed: %s", __PRETTY_FUNCTION__, strerror(errno));
 			}
+			if (send(sendsock, &shmem[idx].key, sizeof(key_t), 0) != sizeof(key_t)) {
+				DBG("%s: ERROR: send() returned not %zu bytes: %s", __PRETTY_FUNCTION__, sizeof(key_t), strerror(errno));
+			}
+			DBG("%s: send FD %d key %08x", __PRETTY_FUNCTION__, shmem[idx].descriptor, shmem[idx].key);
 		} else {
 			DBG("%s: ERROR: cannot find shmid 0x%x", __PRETTY_FUNCTION__, shmid);
 		}
@@ -227,6 +293,7 @@ static void android_shmem_delete(int idx)
 static int ashv_read_remote_segment(int shmid)
 {
 	struct sockaddr_un addr;
+	DBG ("%s: call shmid = %08x", __PRETTY_FUNCTION__, shmid);
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_UNIX;
 	sprintf(&addr.sun_path[1], ANDROID_SHMEM_SOCKNAME, ashv_socket_id_from_shmid(shmid));
@@ -242,26 +309,27 @@ static int ashv_read_remote_segment(int shmid)
 		close(recvsock);
 		return -1;
 	}
-
 	if (send(recvsock, &shmid, sizeof(shmid), 0) != sizeof(shmid)) {
 		DBG ("%s: send() failed on socket %s: %s", __PRETTY_FUNCTION__, addr.sun_path + 1, strerror(errno));
 		close(recvsock);
 		return -1;
 	}
 
-	key_t key;
-	if (read(recvsock, &key, sizeof(key_t)) != sizeof(key_t)) {
-		DBG("%s: ERROR: failed read", __PRETTY_FUNCTION__);
+	int descriptor = ancil_recv_fd(recvsock);
+	if (descriptor < 0) {
+		DBG("%s: ERROR: ancil_recv_fd() failed on socket %s: %s", __PRETTY_FUNCTION__, addr.sun_path + 1, strerror(errno));
 		close(recvsock);
 		return -1;
 	}
 
-	int descriptor = ancil_recv_fd(recvsock);
-	if (descriptor < 0) {
-		DBG("%s: ERROR: ancil_recv_fd() failed on socket %s: %s", __PRETTY_FUNCTION__, addr.sun_path + 1, strerror(errno));
+	key_t key;
+	if (recv(recvsock, &key, sizeof(key_t), 0) != sizeof(key_t)) {
+		DBG("%s: ERROR: recv() returned not %zu bytes: %s", __PRETTY_FUNCTION__, sizeof(key_t), strerror(errno));
 		close(recvsock);
 		return -1;
 	}
+
+	DBG("%s: recv FD %d key %08x", __PRETTY_FUNCTION__, descriptor, key);
 	close(recvsock);
 
 	int size = ashmem_get_size_region(descriptor);
@@ -279,12 +347,20 @@ static int ashv_read_remote_segment(int shmid)
 	shmem[idx].addr = NULL;
 	shmem[idx].markedForDeletion = false;
 	shmem[idx].key = key;
+	DBG ("%s: created new remote shmem ID %d shmid %x FD %d size %zu", __PRETTY_FUNCTION__, idx, shmid, shmem[idx].descriptor, shmem[idx].size);
 	return idx;
 }
 
 /* Get shared memory area identifier. */
 int shmget(key_t key, size_t size, int flags)
 {
+	if (shmem_disabled()) {
+		DBG ("%s: function %s() is disabled.", __PRETTY_FUNCTION__, __PRETTY_FUNCTION__);
+		errno = EACCES;
+		return -1;
+	}
+
+	DBG ("%s: key %08x size %zu flags 0%o (flags are ignored)", __PRETTY_FUNCTION__, key, size, flags);
 	(void) flags;
 
 	ashv_check_pid();
@@ -308,7 +384,10 @@ int shmget(key_t key, size_t size, int flags)
 			ashv_local_socket_id = (getpid() + i) & 0xffff;
 			sprintf(&addr.sun_path[1], ANDROID_SHMEM_SOCKNAME, ashv_local_socket_id);
 			len = sizeof(addr.sun_family) + strlen(&addr.sun_path[1]) + 1;
-			if (bind(sock, (struct sockaddr *)&addr, len) != 0) continue;
+			if (bind(sock, (struct sockaddr *)&addr, len) != 0) {
+				DBG ("%s: cannot bind UNIX socket %s: %s, trying next one, len %d", __PRETTY_FUNCTION__, &addr.sun_path[1], strerror(errno), len);
+				continue;
+			}
 			DBG("%s: bound UNIX socket %s in pid=%d", __PRETTY_FUNCTION__, addr.sun_path + 1, getpid());
 			break;
 		}
@@ -333,6 +412,7 @@ int shmget(key_t key, size_t size, int flags)
 	pthread_mutex_lock(&mutex);
 	char symlink_path[256];
 	if (key != IPC_PRIVATE) {
+		DBG ("%s: key = %08x (is not IPC_PRIVATE)", __PRETTY_FUNCTION__, key);
 		// (1) Check if symlink exists telling us where to connect.
 		// (2) If so, try to connect and open.
 		// (3) If connected and opened, done. If connection refused
@@ -367,9 +447,10 @@ int shmget(key_t key, size_t size, int flags)
 			}
 			if (symlink(num_buffer, symlink_path) == 0) break;
 		}
+	} else {
+		DBG ("%s: key = %08x (is IPC_PRIVATE)", __PRETTY_FUNCTION__, key);
 	}
 
-
 	int idx = shmem_amount;
 	char buf[256];
 	sprintf(buf, ANDROID_SHMEM_SOCKNAME "-%d", ashv_local_socket_id, idx);
@@ -396,7 +477,7 @@ int shmget(key_t key, size_t size, int flags)
 		pthread_mutex_unlock (&mutex);
 		return -1;
 	}
-	//DBG("%s: ID %d shmid %x FD %d size %zu", __PRETTY_FUNCTION__, idx, shmid, shmem[idx].descriptor, shmem[idx].size);
+	DBG("%s: ID %d shmid %x FD %d size %zu", __PRETTY_FUNCTION__, idx, shmid, shmem[idx].descriptor, shmem[idx].size);
 	/*
 	status = ashmem_set_prot_region (shmem[idx].descriptor, 0666);
 	if (status < 0) {
@@ -425,20 +506,28 @@ int shmget(key_t key, size_t size, int flags)
 /* Attach shared memory segment. */
 void* shmat(int shmid, void const* shmaddr, int shmflg)
 {
+	if (shmem_disabled()) {
+		DBG ("%s: function %s() is disabled.", __PRETTY_FUNCTION__, __PRETTY_FUNCTION__);
+		errno = EACCES;
+		return NULL;
+	}
+
 	ashv_check_pid();
 
 	int socket_id = ashv_socket_id_from_shmid(shmid);
 	void *addr;
 
+	DBG ("%s: shmid %08x shmaddr %p shmflg %d", __PRETTY_FUNCTION__, shmid, shmaddr, shmflg);
+
 	pthread_mutex_lock(&mutex);
 
 	int idx = ashv_find_local_index(shmid);
-	if (idx == -1 && socket_id != ashv_local_socket_id) {
+	if ((idx == -1) && (socket_id != ashv_local_socket_id)) {
 		idx = ashv_read_remote_segment(shmid);
 	}
 
 	if (idx == -1) {
-		DBG ("%s: shmid %x does not exist", __PRETTY_FUNCTION__, shmid);
+		DBG ("%s: shmid %08x does not exist", __PRETTY_FUNCTION__, shmid);
 		pthread_mutex_unlock(&mutex);
 		errno = EINVAL;
 		return (void*) -1;
@@ -447,7 +536,7 @@ void* shmat(int shmid, void const* shmaddr, int shmflg)
 	if (shmem[idx].addr == NULL) {
 		shmem[idx].addr = mmap((void*) shmaddr, shmem[idx].size, PROT_READ | (shmflg == 0 ? PROT_WRITE : 0), MAP_SHARED, shmem[idx].descriptor, 0);
 		if (shmem[idx].addr == MAP_FAILED) {
-			DBG ("%s: mmap() failed for ID %x FD %d: %s", __PRETTY_FUNCTION__, idx, shmem[idx].descriptor, strerror(errno));
+			DBG ("%s: mmap() failed for ID %d FD %d: %s", __PRETTY_FUNCTION__, idx, shmem[idx].descriptor, strerror(errno));
 			shmem[idx].addr = NULL;
 		}
 	}
@@ -461,17 +550,25 @@ void* shmat(int shmid, void const* shmaddr, int shmflg)
 /* Detach shared memory segment. */
 int shmdt(void const* shmaddr)
 {
+	if (shmem_disabled()) {
+		DBG ("%s: function %s() is disabled.", __PRETTY_FUNCTION__, __PRETTY_FUNCTION__);
+		errno = EINVAL;
+		return -1;
+	}
+
 	ashv_check_pid();
 
+	DBG ("%s: shmaddr %p", __PRETTY_FUNCTION__, shmaddr);
+
 	pthread_mutex_lock(&mutex);
 	for (size_t i = 0; i < shmem_amount; i++) {
 		if (shmem[i].addr == shmaddr) {
 			if (munmap(shmem[i].addr, shmem[i].size) != 0) {
-				DBG("%s: munmap %p failed", __PRETTY_FUNCTION__, shmaddr);
+				DBG("%s: unmap %p failed", __PRETTY_FUNCTION__, shmaddr);
 			}
 			shmem[i].addr = NULL;
 			DBG("%s: unmapped addr %p for FD %d ID %zu shmid %x", __PRETTY_FUNCTION__, shmaddr, shmem[i].descriptor, i, shmem[i].id);
-			if (shmem[i].markedForDeletion || ashv_socket_id_from_shmid(shmem[i].id) != ashv_local_socket_id) {
+			if (shmem[i].markedForDeletion || (ashv_socket_id_from_shmid(shmem[i].id) != ashv_local_socket_id)) {
 				DBG ("%s: deleting shmid %x", __PRETTY_FUNCTION__, shmem[i].id);
 				android_shmem_delete(i);
 			}
@@ -489,6 +586,12 @@ int shmdt(void const* shmaddr)
 /* Shared memory control operation. */
 int shmctl(int shmid, int cmd, struct shmid_ds *buf)
 {
+	if (shmem_disabled()) {
+		DBG ("%s: function %s() is disabled.", __PRETTY_FUNCTION__, __PRETTY_FUNCTION__);
+		errno = EACCES;
+		return -1;
+	}
+
 	ashv_check_pid();
 
 	if (cmd == IPC_RMID) {
